" Generated by ChatGPT with this prompt:
"
" Please write a vimscript function that looks for code like this in the current file:
"
" ```
"   pagination_order(:weight) do
"     scope { |dir| Banner.reorder(weight: dir) }
"     search { |dir| { weight: { order: dir } } }
"   end
"
"   pagination_order(:period_start) do
"     scope { |dir| Banner.reorder_by_expression('lower(banners.period)', dir) }
"     search { |dir| { 'period.gte': { order: dir } } }
"   end
"
"   pagination_order(:period_end) do
"     scope { |dir| Banner.reorder_by_expression('upper(banners.period)', dir) }
"     search { |dir| { 'period.lte': { order: dir } } }
"   end
"
"   pagination_order(:created_at) do
"     scope { |dir| Banner.reorder(created_at: dir) }
"     search { |dir| { created_at: { order: dir } } }
"   end
" ```
"
" and converts it into code like this:
"
" ```
"   order?: Order.Weight | Order.PeriodStart | Order.PeriodEnd | Order.CreatedAt;
" ```
"
" and the follow up prompt:
"
" Please update the script to capitalize the first letter of the Order enum entries. For example it should output:
"
" order?: Order.Weight | Order.PeriodStart | Order.PeriodEnd | Order.CreatedAt;
"
" instead of outputting:
"
" order?: Order.weight | Order.periodStart | Order.periodEnd | Order.createdAt;
function! _ConvertPaginationOrder()
  " Define a pattern to match pagination_order lines and extract field names
  let l:pattern = '^\s*pagination_order(\(.*\))\s*do$'
  let l:fields = []

  " Iterate through lines in the current buffer
  let l:lnum = 1
  while l:lnum <= line('$')
    let l:line = getline(l:lnum)
    if l:line =~ l:pattern
      " Extract the field name (remove parentheses and whitespace)
      let l:match = matchlist(l:line, l:pattern)
      if !empty(l:match)
        let l:field = substitute(l:match[1], '[:()]', '', 'g')
        let l:field = substitute(l:field, '_\(\w\)', '\u\1', 'g') " Convert snake_case to CamelCase
        let l:field = substitute(l:field, '^\(\w\)', '\u\1', '') " Capitalize first letter
        call add(l:fields, 'Order.' . l:field)
      endif
    endif
    let l:lnum += 1
  endwhile

  " Construct the replacement line
  if !empty(l:fields)
    let l:replacement = '  order?: ' . join(l:fields, ' | ') . ';'
    call setline(1, l:replacement) " Replace the first line with the new type definition
  endif
endfunction

function! _ConvertRequestFilter()
  " Define a pattern to match request_filter lines and extract field names
  let l:pattern = '^\s*request_filter(\(.*\))\s*do$'
  let l:fields = []

  " Iterate through lines in the current buffer
  let l:lnum = 1
  while l:lnum <= line('$')
    let l:line = getline(l:lnum)
    if l:line =~ l:pattern
      " Extract the field name (remove parentheses and whitespace)
      let l:match = matchlist(l:line, l:pattern)
      if !empty(l:match)
        let l:field = substitute(l:match[1], '[:()]', '', 'g')
        let l:comment = ''

        " Check if a format line exists within the block
        let l:block_lnum = l:lnum + 1
        while l:block_lnum <= line('$')
          let l:block_line = getline(l:block_lnum)
          if l:block_line =~ '^\s*format\s\+\(.\+\)$'
            let l:format_match = matchlist(l:block_line, '^\s*format\s\+\(.*\)$')
            if !empty(l:format_match)
              let l:comment = ' // format ' . l:format_match[1]
            endif
          endif
          if l:block_line =~ '^\s*end\s*$'
            break
          endif
          let l:block_lnum += 1
        endwhile

        call add(l:fields, '  ' . l:field . '?: CustomStringifiableRecord[string];' . l:comment)
      endif
    endif
    let l:lnum += 1
  endwhile

  " Construct the replacement block
  if !empty(l:fields)
    let l:replacement = split(join(l:fields, "\r\n"), "\r\n")
    call append(0, l:replacement) " Insert at the top without modifying existing lines
  endif
endfunction

" Generated with ChatGPT by asking it to combine the above functions and
" adding some special cases for common formats.
function! ConvertFiltersAndOrders()
  " Define patterns to match pagination_order and request_filter lines
  let l:pagination_pattern = '^\s*pagination_order(\(.*\))\s*do$'
  let l:request_pattern = '^\s*request_filter(\(.*\))\s*do$'
  let l:fields = []
  let l:orders = []

  " Iterate through lines in the current buffer
  let l:lnum = 1
  while l:lnum <= line('$')
    let l:line = getline(l:lnum)

    if l:line =~ l:pagination_pattern
      " Extract the pagination field name and convert to PascalCase
      let l:match = matchlist(l:line, l:pagination_pattern)
      if !empty(l:match)
        let l:field = substitute(l:match[1], '[:()]', '', 'g')
        let l:field = substitute(l:field, '_\(\w\)', '\u\1', 'g')
        let l:field = substitute(l:field, '^\(\w\)', '\u\1', '') " Capitalize first letter
        call add(l:orders, 'Order.' . l:field)
      endif

    elseif l:line =~ l:request_pattern
      " Extract the request filter field name
      let l:match = matchlist(l:line, l:request_pattern)
      if !empty(l:match)
        let l:field = substitute(l:match[1], '[:()]', '', 'g')
        let l:comment = ''
        let l:type = 'CustomStringifiableRecord[string]'

        " Check if a format line exists within the block
        let l:block_lnum = l:lnum + 1
        while l:block_lnum <= line('$')
          let l:block_line = getline(l:block_lnum)
          if l:block_line =~ '^\s*format\s\+\(.\+\)$'
            let l:format_match = matchlist(l:block_line, '^\s*format\s\+\(.*\)$')
            if !empty(l:format_match)
              let l:format = l:format_match[1]
              if l:format ==# 'IknowParams::Serializer::Boolean'
                let l:type = 'boolean'
              elseif l:format ==# 'ParamSerializers::Time'
                let l:type = 'EncodedDateOrNow'
              elseif l:format ==# 'IknowParams::Serializer::UUID'
                let l:type = 'EntityStringId'
              elseif l:format ==# 'IknowParams::Serializer::ArrayOf.new(IknowParams::Serializer::UUID, allow_singleton: true)'
                let l:type = 'EntityStringId | EntityStringId[]'
              else
                let l:comment = ' // format ' . l:format
              endif
            endif
          endif
          if l:block_line =~ '^\s*end\s*$'
            break
          endif
          let l:block_lnum += 1
        endwhile

        call add(l:fields, '  ' . l:field . '?: ' . l:type . ';' . l:comment)
      endif
    endif

    let l:lnum += 1
  endwhile

  " Construct the order type union
  if !empty(l:orders)
    let l:order_line = '  order?: ' . join(l:orders, ' | ') . ';'
    call insert(l:fields, l:order_line, 0)
  endif

  " Insert the generated lines at the top
  if !empty(l:fields)
    let l:replacement = split(join(l:fields, "\r\n"), "\r\n")
    call append(0, l:replacement)
  endif
endfunction
